using System;
using System.Collections.Generic;
using System.IO;
using _build;
using Nuke.Common;
using Nuke.Common.CI;
using Nuke.Common.CI.GitHubActions;
using Nuke.Common.CI.GitHubActions.Configuration;
using Nuke.Common.Git;
using Nuke.Common.IO;
using Nuke.Common.ProjectModel;
using Nuke.Common.Tooling;
using Nuke.Common.Tools.GitVersion;
using Nuke.Common.Tools.MSBuild;
using NukePlusPlus;
using static Nuke.Common.EnvironmentInfo;
using static Nuke.Common.IO.FileSystemTasks;
using static Nuke.Common.Tools.MSBuild.MSBuildTasks;
[OurGitHubActions(
	"continuous",
	ArchOptions.x86, ArchOptions.x64,
	GitHubActionsImage.WindowsLatest, GitHubActionsImage.UbuntuLatest, GitHubActionsImage.Ubuntu1804,
	ConfigOptions.Debug, ConfigOptions.Release,
	OnPushBranchesIgnore = new[] { "trash" },
	//OnPushBranchesIgnore = new[] { MasterBranch, ReleaseBranchPrefix + "/*" },
	Submodules = GitHubActionsSubmodules.Recursive,
	PublishArtifacts = true,
	InvokedTargets = new[] { nameof(Pack) }
)]
class Build : OurNukeBuild {
	
	/// Support plugins are available for:
	///   - JetBrains ReSharper        https://nuke.build/resharper
	///   - JetBrains Rider            https://nuke.build/rider
	///   - Microsoft VisualStudio     https://nuke.build/visualstudio
	///   - Microsoft VSCode           https://nuke.build/vscode


	[LocalExecutable("httrack/configure")]
	readonly Tool LinConfigure;
	[PathExecutable("make")]
	readonly Tool LinMake;

	public Build() {
		OnConfigurationEntityInitalized<GitHubActionsArtifactStep>((step) => step.Name = $"httrack-{Mtx(nameof(BaseImage))}-{Mtx(nameof(Configuration))}-{Mtx(nameof(Arch))}");
		OnConfigurationEntityInitalized<OurGitHubActionsCheckoutStep>((step) => step.Repository = "mitchcapper/httrack-windows");//while we run the action on the main repo we actually have the build files in the windows repo
		
		AddNewWritingItem<GithubActionsCommentWriter>(writer => {
			writer.level = BaseOurConfigurationEntity.WRITE_LEVEL.Global;
			writer.priority = BaseOurConfigurationEntity.PRIORITY.First;
			writer.AddComment("This workflow is generated by the nuke configuration on mitch-capper/httrack-windows. It runs on the main httrack repo however.");
		});
		AddNewWritingItem<GithubActionsEnvWriter>(writer => {
			writer.level = BaseOurConfigurationEntity.WRITE_LEVEL.Global;
			writer.AddVar("NUKE_TELEMETRY_OPTOUT", 1.ToString());
		});

	}
	protected override void OnBuildInitialized() {

		base.OnBuildInitialized();
		ProcessTasks.DefaultLogInvocation = true;
		ProcessTasks.DefaultLogOutput = true;
		Serilog.Log.Information("IsLocalBuild           : {0}", IsLocalBuild.ToString());

		Serilog.Log.Information("Informational   Version: {0}", InformationalVersion);
		Serilog.Log.Information("SemVer          Version: {0}", SemVer);
		Serilog.Log.Information("AssemblySemVer  Version: {0}", AssemblySemVer);

	}
	const string MasterBranch = "master";
	const string ReleaseBranchPrefix = "tags";
	[GitRepository] GitRepository GitRepository;
	[GitVersion(NoFetch = true, NoCache = true)] readonly GitVersion GitVersion;
	string AssemblySemVer => GitVersion?.AssemblySemVer ?? "1.0.0";
	string SemVer => GitVersion?.SemVer ?? "1.0.0";
	string InformationalVersion => GitVersion?.InformationalVersion ?? "1.0.0";

	[CI] readonly GitHubActions GitHubActions;
	//[Parameter]
	//readonly AbsolutePath ArtifactsDirectory = RootDirectory / "artifacts";
	[Parameter]
	public readonly GitHubActionsImage BaseImage;
	[Parameter("Architecture to build - Default is 'x64'")]
	public readonly ArchOptions Arch;

	public static int Main() => Execute<Build>(x => x.Compile);

	[Parameter("Configuration to build - Default is 'Debug' (local) or 'Release' (server)")]
	public readonly ConfigOptions Configuration = IsLocalBuild ? ConfigOptions.Debug : ConfigOptions.Release;




	//[Parameter("Platform to build for - Default is current os")]
	//public readonly Platform Platform = IsWin ? Platform.Windows : Platform.Linux;

	[Solution(GenerateProjects = true)] readonly Solution Solution = null!;
	AbsolutePath OutputDirectory => RootDirectory / "final";

	Target CleanOutput => _ => _
		.Executes(() =>
			EnsureCleanDirectory(OutputDirectory)
			);

	Target ActionUpdateOnly => _ => _
		.Executes(() => Console.WriteLine("Updated if any changes"));

	Target Clean => _ => _
		.DependsOn(CleanOutput)
		.Executes(() => {
			if (IsWin)
				OurMSBuild(s => s.SetTargets("Clean"));
			else { }



		});
	private IReadOnlyCollection<Output> OurMSBuild(Func<MSBuildSettings, MSBuildSettings> action, Project ScopeToSpecificProject = null) {
		var toolsPath = MSBuildToolPathResolver.Resolve(MSBuildVersion.VS2022, MSBuildPlatform.x64);

		MSBuildSettings s = new OurMSBuildSettings();
		if (ScopeToSpecificProject != null)
			s = s.SetProjectFile(ScopeToSpecificProject);
		else
			s = s.SetSolutionFile(Solution);
		s = s.SetProcessToolPath(toolsPath)
		.SetConfiguration(Configuration.ToString())
		.SetMSBuildPlatform(Arch == ArchOptions.x64 ? MSBuildPlatform.x64 : MSBuildPlatform.x86)
		.SetVerbosity(MSBuildVerbosity.Normal)
		.SetOutDir(OutputDirectory);

		s = action(s);
		return MSBuild(s);
	}
	Target Restore => _ => _
		.Executes(() => {
			if (IsWin)
				OurMSBuild(s => s.SetRestore(true).SetTargets("restore"));

		});

	Target Compile => _ => _
		.DependsOn(Clean)
		.DependsOn(Restore)
		.Executes(() => {

			EnsureCleanDirectory(OutputDirectory);
			if (IsWin) {
				var toBuild = new[] { Solution.WinHTTrack, Solution.httrack, Solution.libhttrack, Solution.proxytrack };

				foreach (var proj in toBuild) {
					var context = Serilog.Log.ForContext("Project", $"Building {proj.Name}");
					context.Information($"Starting build of: {proj.Name}");
					OurMSBuild(s => s
					.SetTargets("Build")
					.SetAssemblyVersion(AssemblySemVer)
					.SetInformationalVersion(InformationalVersion), proj
					);
				}
			} else {
				var forceFail = "";
				//if (GitHubActions.Instance.Job.Contains("latest") == false)
				//	forceFail = "CFLAGS=\" -D _WIN32\"";
				LinConfigure($"--prefix=\"{OutputDirectory}\" {forceFail}", "httrack", logOutput: true, logInvocation: true);
				LinMake("", "httrack", logOutput: true, logInvocation: true, customLogger: GCCLogHandler);
				LinMake("install", "httrack", logOutput: true, logInvocation: true, customLogger: GCCLogHandler);





			}



		});
	protected override void OnTargetFailed(string target) {
		Serilog.Log.Error($"TARGET FAILURE: {target}");
		if (target == nameof(Compile) && IsLinux)
			TryWriteLogFileTo(@"httrack/config.log", Serilog.Log.Information, ()=>Serilog.Log.Error("Unable to find config.log????"));
		
		base.OnTargetFailed(target);
	}

	

	Target Pack => _ => _
		.DependsOn(CleanOutput)
		.DependsOn(Compile)
		.Produces(OutputDirectory)
		.Executes(() => {


		});
}

